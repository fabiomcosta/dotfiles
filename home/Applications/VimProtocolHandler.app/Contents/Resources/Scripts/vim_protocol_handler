#!/usr/bin/python3

# TODO
# * Provide helpful error if trying to open a file that is not available to the nvim instance.
#   Example: trying to open an fbsource link on a server that only contains www.
# * [DONE] Support local links for projects known to be local, like wa-js
# * Support et?

import os
import sys
import logging
import subprocess
import re
from urllib.parse import urlparse, parse_qs, unquote

dirname = os.path.dirname(__file__)
name = os.path.basename(__file__)

logpath = '/tmp/{}.log'.format(name)
logging.basicConfig(
  filename=logpath,
  level=logging.DEBUG,
  format='%(asctime)s %(levelname)s %(name)s %(message)s'
)
logger = logging.getLogger(name)


def run_proc(cmd):
  logger.debug(cmd)
  try:
    return subprocess.run(cmd, shell=isinstance(cmd, str), check=True, capture_output=True)
  except subprocess.CalledProcessError as error:
    logger.error('\n{}\n{}'.format(error, error.stderr))


def run(cmd):
  proc = run_proc(cmd)
  if proc is None:
    return
  return proc.stdout.decode('utf-8').strip() or True


def log_error(message):
  message = str(message)
  notify('{}. See error logs at {}'.format(re.sub(r'\.+$', '', message), logpath))
  logger.error(message)


def log_error_and_exit(message):
  log_error(message)
  sys.exit(1)


def notify(text, title = 'Vim Protocol Handler'):
  def quote(t):
    return t.replace('"', '\\"')
  run(['osascript', '-e', 'display notification "{}" with title "{}"'.format(quote(text), quote(title))])


def focus_currently_open_terminal():
  run(['osascript', '{}/focus_currently_open_terminal.scpt'.format(dirname)])


def tmux_select_window_by_tty(tty):
  tmux_pane_id = run("tmux list-panes -a -F '#{pane_tty} #{pane_id}' | grep "+ tty +" | awk '{print $2}'")
  # ex: %19
  logger.debug('tmux pane id: {}'.format(tmux_pane_id))

  run('tmux select-window -t {}'.format(tmux_pane_id))


def focus_tmux_window_with_ssh():
  # TODO, only do this if user actually is using tmux

  # getting hostname from the server running the nvim instance that is listening to localhost:8082
  # not sure why it goes to stderr, but it is what it is.
  hostname = run_proc("nvim --server localhost:8082 --remote-expr 'hostname()'").stderr.decode('utf-8').strip()
  # ex: 34120.od.fbinfra.net
  logger.debug('hostname: {}'.format(hostname))

  # getting the tty for the local ssh command that connects to the hostname running nvim
  tty = run("ps -o tty= -o command= | grep ssh | grep "+ hostname +" | grep -v grep | awk '{print $1}'")
  # ex: ttys011
  logger.debug('tty: {}'.format(tty))

  tmux_select_window_by_tty(tty)


def parse_and_validate_url(url):
  parsed_url = urlparse(url)
  parsed_qs = parse_qs(parsed_url.query)

  validation = {
    'scheme': ['fb-vscode'],
    'netloc': ['nuclide.core'],
    'path': ['/open-arc'],
  }

  if parsed_url.scheme not in validation['scheme']:
    log_error_and_exit('scheme (protocol) not supported on {}. Supported schemes: {}'.format(url, validation['scheme']))

  if parsed_url.netloc not in validation['netloc']:
    log_error_and_exit('application (domain) not supported on {}. Supported applications: {}'.format(url, validation['netloc']))

  if parsed_url.path not in validation['path']:
    log_error_and_exit('command (path) not supported on {}. Supported commands: {}'.format(url, validation['path']))

  if not 'project' in parsed_qs:
    log_error_and_exit('No "project" query param found on {}.'.format(url))

  if not 'path' in parsed_qs:
    log_error_and_exit('No "path" query param found on {}.'.format(url))

  return parsed_url, parsed_qs


def get_supported_project_paths(project_name):
  # Setup your symlinks for your relevant arcanist project
  project_to_path = {
    'local': {
      'wa-js': '~/local/whatsapp/wajs/',
    },
    'remote': {
      'facebook-www': '~/www/',
      'facebook-admin': '~/admin/',
      'opsfiles': '~/opsfiles/',
      'fbsource': '~/fbsource/',
    }
  };

  if not project_name in project_to_path['local'] and not project_name in project_to_path['remote']:
    log_error_and_exit('Project {} not supported.\nSupported local projects: {}\nSupported remote projects: {}'.format(project_name, project_to_path['local'].keys(), project_to_path['remote'].keys()))

  project = {}

  if project_name in project_to_path['local']:
    project['local'] = project_to_path['local'][project_name]

  if project_name in project_to_path['remote']:
    project['remote'] = project_to_path['remote'][project_name]

  return project


def attempt_to_open_file_remotely(file):
  if run(['nvim', '--server', 'localhost:8082', '--remote-send', ':e {} {}<CR>'.format(file['line'], file['path'])]):
    return True

  log_error("Couldn't open file remotely. Make sure to define the NVIM_LISTEN_ADDRESS='localhost:8082' env variable before running a neovim instance on your server.")
  return False


def get_currently_open_nvim_processes():
  # Get the socket paths that nvim is using to listen to commands
  # With the cwd from each of these processes we can smartly detect the right
  # nvim instance to send the commands to.
  '''
    Example output of this command:

      p4902
      fcwd
      n/Users/fabs/Dev/own/dotfiles
      f16
      n/var/folders/gc/ljcry8fs5cd7qc7h2c25d9gc0000gn/T/nvimkhqK1z/0
      p36781
      fcwd
      n/Users/fabs/local/whatsapp/wajs/web
      f16
      n/var/folders/gc/ljcry8fs5cd7qc7h2c25d9gc0000gn/T/nvimjI8WjN/0
  '''
  lsof_lines = run('lsof -a -F pfn -P -n -d 16 -d cwd -c nvim').split('\n')

  processes = {}
  pid = None
  field_name = None

  for line in lsof_lines:
    field_key = line[0]
    field_value = line[1:]
    if field_key == 'p':
      pid = field_value
      processes[pid] = {'pid': pid}
      continue
    if field_key == 'f':
      # "16" is not readable/understandable, renaming it to something more descriptive
      field_name = 'unix_socket_path' if field_value == '16' else field_value
      continue
    if field_key == 'n':
      processes[pid][field_name] = field_value
      continue

  return processes


def attempt_to_open_file_locally(file):
  processes = get_currently_open_nvim_processes()
  project_path = os.path.realpath(os.path.expanduser(file['project_path']))
  file_path = os.path.realpath(os.path.expanduser(file['path']))

  nvim_process = next(v for k, v in processes.items() if v['cwd'].startswith(project_path))

  if nvim_process is None:
    log_error("Couldn't find a nvim process running on your project's folder: {}".format(project_path))

  logger.info('Found nvim process {} running on {}'.format(nvim_process, project_path))

  nvim_tty = run(['ps', '-o', 'tty=', nvim_process['pid']])

  socket_path = nvim_process['unix_socket_path']

  if run(['nvim', '--server', socket_path, '--remote-send', ':e {} {}<CR>'.format(file['line'], file['path'])]):
    # TODO idealy this would happen outside this function
    tmux_select_window_by_tty(nvim_tty)
    return True

  log_error("Couldn't open file locally. Make sure you have a nvim instance running locally on your project's folder.")
  return False


def main(url):
  # assuming nvim and tmux (optional) were installed via homebrew
  os.environ['PATH'] += ':/usr/local/bin/'

  logger.info('Handling url {}'.format(url))

  parsed_url, parsed_qs = parse_and_validate_url(url)

  project_paths = get_supported_project_paths(parsed_qs['project'][0])
  relative_file_path = unquote(parsed_qs['path'][0])
  line = '+{}'.format(parsed_qs['line'][0]) if 'line' in parsed_qs else ''

  logger.info('Trying to open {} on {}...'.format(relative_file_path, project_paths))

  # We'll prefer trying to open the file on a remove server over locally
  # As if there is a server open that is capable of opening this file, it's
  # very likely that the user wants to use the server, instead of trying
  # to open it locally.
  if 'remote' in project_paths:
    file_path = os.path.normpath(os.path.join(project_paths['remote'], relative_file_path))
    file = {'path': file_path, 'line': line}

    logger.info('Trying to open file remotely...')
    if attempt_to_open_file_remotely(file):
      logger.info('Successfully opened file remotely.')
      notify('Opened {} on your remote editor.'.format(file['path']))
      focus_tmux_window_with_ssh()
      focus_currently_open_terminal()
      return sys.exit(0)

  if 'local' in project_paths:
    project_path = project_paths['local']
    file_path = os.path.normpath(os.path.join(project_path, relative_file_path))
    file = {'project_path': project_path, 'path': file_path, 'line': line}

    logger.info('Trying to open file locally...')
    if attempt_to_open_file_locally(file):
      logger.info('Successfully opened file locally.')
      notify('Opened {} on your local editor.'.format(file['path']))
      focus_currently_open_terminal()


if __name__ == '__main__':
  if len(sys.argv) < 2:
    log_error_and_exit('expects 1 argument')

  try:
    main(sys.argv[1])
  except Exception as error:
    log_error_and_exit(error)
